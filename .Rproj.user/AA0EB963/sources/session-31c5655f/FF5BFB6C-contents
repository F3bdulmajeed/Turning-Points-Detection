library(Rcpp)
library(Rfast)
sourceCpp("FPOPS.cpp")

adjust_range <- function(h){
  return( (h+pi)%%(2*pi)-pi)
}

seg_iid = function(h , rho , kappa , model = "IID"){
  n <- length(h)
  C <- -2*log(n)
  penalty <-  C/kappa    
  
  iidseg_estimation <- function(){
    penalty <-  penalty  * (1+rho)/(1-rho)
    tps <- AFPOP(sin(h), cos(h), penalty)
    sort(tps)
  }
  
  ar1seg_estimation <- function(){
    mu <- seq(-pi,pi,  length = 720 )
    cos_h <- cos(h) ; sin_h <- sin(h) ; cos_mu<- cos(mu) ; sin_mu<- sin(mu)
    Msine <- Outer(sin_h , sin_mu , "*")
    Mcosine <- Outer(cos_h , cos_mu , "*")
    D <- cos(diff(h))
    M <-  Msine + Mcosine
    tps <- DFPOP(M,D,rho,penalty)
    sort(tps)
  }
  
  
  if(model == "IID"){
    return(iidseg_estimation())
  }else{
    if(rho == 0){
      return(iidseg_estimation())
    }else{
      return(ar1seg_estimation())
    }
  }
  
}



robust_params_estimation  <- function(h , max_rho) {
  h <- na.omit(h)
  d1 <- adjust_range(diff(h,1))
  d2 <- adjust_range(diff(h,2))
  md1 <- atan2( median(sin(d1)), median(cos(d1)))
  md2 <- atan2( median(sin(d2)), median(cos(d2)))
  d1 <- adjust_range(d1 - md1)
  d2 <- adjust_range(d2 - md2)
  sd1 <- sin(d1)
  cd1 <- cos(d1)
  cd2 <- cos(d2)
  n <-  length(sd1)
  med_cd1 <-  median(  (1-cd1)  ) 
  med_cd2 <-  median(  (1-cd2)  ) 
  rho    <-    min( med_cd2/med_cd1 - 1 , max_rho )
  dewhitened_h <- d1[-1] - atan2(rho*sd1[-n] ,1-rho + rho*cd1[-n])
  kappa_rho <- 1/(2.19*median(1-cos(dewhitened_h)) )
  rho_mu <-  kappa_rho*(1-rho^2)
  return(c(rho , kappa_rho, rho_mu))
}


convert_bearings_to_steps.turns <- function(h , tps){
  diffh <- cos(diff(h))
  end.vec = tps[-1]
  change.vec <- end.vec[-length(end.vec)]
  start.vec <- c(1,change.vec+1)
  seg.mean <- c()
  for(seg.i in seq_along(start.vec)){
    start <- start.vec[seg.i]
    end <- end.vec[seg.i]
    seg.data <- h[start:end]
    seg.mean[seg.i]  <-  CircStats::circ.mean(seg.data) 
  }
  seg.mean <- data.frame( x= adjust_range( c(diff(seg.mean), 0) ),
                          y = diff(tps)
  )
}


nonparam_estimation  <- function(h, window, align) {
  s <- sin(h)
  c <- cos(h)
  ms <- zoo::rollmedian(s, window , na.pad = TRUE , align = align)
  mc <- zoo::rollmedian(c, window , na.pad = TRUE , align = align)
  med_head <- atan2(ms, mc)
  errors   <- na.omit( adjust_range(  h - med_head  ) )
  sin_errors <- sin(errors)
  cos_errors <- cos(errors)
  n <- length(sin_errors)
  rho <-  sum( sin_errors[-1]*sin_errors[-n] ) / sqrt(   sum( sin_errors[-1]^2 ) * sum( sin_errors[-n]^2 ) )
  whitened_h <- adjust_range( errors[-1] - atan2(rho*sin_errors[-n] ,1- rho + rho*cos_errors[-n]) )
  kappa_rho <-  circular::mle.vonmises(circular::circular( whitened_h ) )
  rho_mu <-  circular::mle.vonmises(circular::circular( errors ) )
  return(c(rho , kappa_rho$kappa , rho_mu$kappa))
}


# 
# calculate_expected_headings <- function(h , tps ,rho){
#   q <- rho/(1-rho)
#   diffh <- cos(diff(h))
#   end.vec = tps[-1]
#   change.vec <- end.vec[-length(end.vec)]
#   start.vec <- c(1,change.vec+1)
#   seg.mean <- numeric(length = length(h))
#   for(seg.i in seq_along(start.vec)){
#     start <- start.vec[seg.i]
#     end <- end.vec[seg.i]
#     seg.data <- h[start:end]
#     seg.mean[start:end]  <- rep(  CircStats::circ.mean(seg.data) , length(seg.data)  )
#   }
#   h_prev <- h[-length(h)]
#   mu_new<- seg.mean[-1]
#   expec <- atan2(
#     sin(mu_new) + q*sin(h_prev),
#     cos(mu_new) + q*cos(h_prev)
#   )
#   expec <- (expec+pi)%%(2*pi)-pi
#   expec
# }
# 









