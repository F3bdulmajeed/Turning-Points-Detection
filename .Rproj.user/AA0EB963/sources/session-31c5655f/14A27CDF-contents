################################################################################
# Name: find_turnpoints.R
#
# Purpose: Find turning points in high-resolution data on animal headings
#
# Author: Jonathan Potts
#
# Reference: Potts JR, Borger L, Scantlebury DM, Bennett NC, Alagaili A, Wilson
#   RP. Finding turning-points in ultra-high-resolution animal movement data.
#   Methods Ecol Evol. 2018;00:1â€“11. https://doi.org/10.1111/2041-210X.13056
#
# Date created: Dec 18 2017
#
# Note: The first three lines of code, setting the variables 'headings', 
#       'window_size', and 'thresh', will need to be altered.  Comments
#       above each line explain how this is done.
################################################################################

# Get headings from file.
# In our example we are using the file: headings.txt
# Replace this with the name of your file, which should contain a single 
#   column listing the headings in order in degrees.
# Note that you need to be in the right working directory (see ?setwd()).
headings <- read.table("headings.txt", blank.lines.skip=FALSE)

# Set window size, which is denoted W in the paper
window_size <- 40

# Set threshold angle in degrees, denoted theta_{thresh} in the paper
thresh <- 30

# Calculate sin and cosine of headings, together with x- and y-values 
# (assuming a constant speed)
cosines <- cos(headings[,1]*pi/180)
sines <- sin(headings[,1]*pi/180)
x_vals <- cumsum(cosines)
y_vals <- cumsum(sines)

# Find average cos and sin over sliding window, as well as 
# squared circular standard deviations (SCSD)
sd_length <- length(cosines) - window_size
ave_cos_array <- cosines[1:sd_length]/window_size
ave_sin_array <- sines[1:sd_length]/window_size
for(counter in 1:(window_size-1))
{
  # Shift cosine and sin arrays back by 1
  cosines <- cosines[-1]
  sines <- sines[-1]
  ave_cos_array <- ave_cos_array + cosines[1:sd_length]/window_size
  ave_sin_array <- ave_sin_array + sines[1:sd_length]/window_size
}
circ_sd <- (-2)*log(sqrt((ave_sin_array)^2 + (ave_cos_array)^2))
ave_circ_sd <- sum(circ_sd) / length(circ_sd)

# Find candidate turning points by looking for spikes in SCSD
turning <- 0
chgpt_array <- c(1)
for(counter in 1:length(circ_sd))
{
  if((circ_sd[counter] > ave_circ_sd)&(turning == 0))
  {
    # Started turning.  Note turning point
    start_chgpt <- counter 
    turning <- 1
  }
  if((circ_sd[counter] < ave_circ_sd)&(turning == 1))
  {
    # Turning point is the mean of the start turning-point and the end shifted to the right by resolution/2 
    # to account for averaging being done forwards in time
    chgpt <- floor((start_chgpt + counter)/2 + window_size/2)
    chgpt_array <- c(chgpt_array,chgpt)
    turning <- 0
  }
}
chgpt_array <- c(chgpt_array, length(cosines))

# Post processing of changepoints to remove any where the switch in direction is less than thresh_angle
new_chgpt_array <- vector(mode="numeric", length=0)
prev_heading <- atan2(y_vals[chgpt_array[2]]-y_vals[chgpt_array[1]],
                      x_vals[chgpt_array[2]]-x_vals[chgpt_array[1]])
for(counter in 2:(length(chgpt_array)-1))
{
  next_heading <- atan2(y_vals[chgpt_array[counter+1]]-y_vals[chgpt_array[counter]],
                        x_vals[chgpt_array[counter+1]]-x_vals[chgpt_array[counter]])                              
  if(abs(next_heading - prev_heading) > pi)
  {
    turn_angle <- pi*2-abs(next_heading - prev_heading)
  }
  else
  {
    turn_angle <- abs(next_heading - prev_heading)
  }
  if(turn_angle*180/pi > thresh)
  {
    new_chgpt_array <- c(new_chgpt_array, chgpt_array[counter])
    prev_heading = next_heading  
  }
}